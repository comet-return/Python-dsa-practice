Q1. Explain Class and Object with respect to Object-Oriented Programming. Give a suitable example.

In object-oriented programming (OOP), classes and objects are the fundamental building blocks. They play a crucial role in creating and organizing code, making 
it more modular, reusable, and maintainable.

Class:

A class is a blueprint or template for creating objects. It defines the characteristics and behaviors that are common to all objects of a particular type. A 
class is like a detailed description of what an object will look like and how it will behave. It encapsulates data (attributes) and methods (functions) that 
represent the properties and operations associated with that type of object.

Object:

An object is an instance of a class. It is a concrete entity that exists in memory and has specific values for the attributes defined in its class. Objects
 represent real-world entities or abstract concepts. They interact with each other by sending and receiving messages, which are essentially calls to their methods.

Example:

Consider the class 'Car'. This class would define the characteristics common to all cars, such as:

Attributes: make, model, year, color, mileage
Methods: startEngine(), stopEngine(), accelerate(), brake()
Objects of the 'Car' class would be individual cars, such as a 'Toyota Camry' or a 'Honda Civic'. Each object would have its own specific values for the attributes,
such as 'make': 'Toyota', 'model': 'Camry', 'year': 2023, 'color': 'Silver', 'mileage': 5000. Each object would also be able to perform the methods defined in the
class, such as starting the engine, stopping the engine, accelerating, and braking.

In summary, classes provide the blueprint, while objects are the actual instances of those blueprints. Classes define the structure and behavior of objects, while
objects contain the specific data and functionality for each individual instance. This distinction is essential for organizing and managing code in object-oriented 
programming.


Q2. Name the four pillars of OOPs.


The four pillars of object-oriented programming (OOP) are:

Abstraction: Abstraction is the process of simplifying a complex system by hiding its internal details and only exposing the essential information to the user.
 This allows the user to interact with the system without needing to understand its intricacies. In OOP, abstraction is achieved through the use of interfaces 
 and abstract classes.

Encapsulation: Encapsulation is the bundling of data and methods that operate on that data into a single unit, called an object. This helps to protect the data
 from outside interference and ensures that it is only accessed through the defined methods. Encapsulation is achieved through the use of access modifiers, such 
 as public, private, and protected.

Inheritance: Inheritance is the ability of a class to inherit the properties and methods of another class. This allows for code reuse and promotes code 
organization. In OOP, inheritance is implemented using a class hierarchy, where subclasses inherit from parent classes.

Polymorphism: Polymorphism is the ability of an object to take on many forms. This means that an object can respond to the same method call in different ways, 
depending on its type. Polymorphism is achieved through method overloading and method overriding, as well as through the use of interfaces.

These four pillars form the foundation of OOP and are essential for writing clean, maintainable


Q3. Explain why the __init__() function is used. Give a suitable example.



The __init__() function, also known as the constructor, is a special method in Python that is called automatically whenever a new object is created from a class. Its primary purpose is to initialize the object's attributes, which are essentially the variables that define the state of the object.

Why is the __init__() function important?

The __init__() function plays a crucial role in object-oriented programming (OOP) for several reasons:

1.Attribute Initialization: It ensures that each newly created object starts with proper values for its attributes, preventing undefined or unexpected behavior.

2.Custom Object Creation: It allows for the creation of objects with customized attributes and values, tailoring them to specific requirements.

3.Object State Management: It provides a controlled mechanism for setting up the initial state of an object, ensuring consistency and predictability.

4.Code Organization: It promotes modularity and code organization by encapsulating attribute initialization within the class definition.


Q.4 Why self is used in OOPs?


The self keyword is a special parameter used in methods of object-oriented programming (OOP) languages like Python. It serves a crucial role in referencing the current object
 within the method, allowing the method to interact with the object's attributes and methods.

Purpose of the self Keyword:

1.Object Referencing: The self keyword acts as a placeholder for the current object within the method. It allows the method to access and modify the object's attributes
 and methods.

2.Method Binding: When a method is called on an object, the object is automatically passed as the first argument to the method. This argument is referred to as self.

3.Attribute Access: Within a method, the self keyword is used to access the attributes of the current object. For example, self.name refers to the name attribute of the 
object.

4.Method Invocation: The self keyword can be used to call other methods of the current object. For instance, self.other_method() calls the other_method method on the object.


Q5. What is inheritance? Give an example for each type of inheritance.

Inheritance is a fundamental concept in object-oriented programming (OOP) that allows one class to inherit the properties and methods of another class. This creates a
hierarchical relationship between classes, enabling code reuse and promoting a more organized and maintainable codebase.

type :
1.single inheritance
2.multilevel inheritance
3.multiple inheritance



















































